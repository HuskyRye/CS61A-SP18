(define (deeval num k)
	(cond ((and (= num 0) (= k 0)) 1)
		  ((and (not (= num 0)) (= k 0)) 0) 
		  (else (+
					(if (= (modulo num k) 0) (deeval (/ num k) (- k 1)) 0)
					(deeval (- num k) (- k 1))))))
					
(define (pair-add p1 p2) (cons (+ (car p1) (car p2)) (+ (cdr p1) (cdr p2))))
(define (len lst) (if (null? lst) 0 (+ 1 (len (cdr lst)))))
(define (cadr lst) (car (cdr lst)))
(define (caddr lst) (car (cdr (cdr lst))))
(define (cadddr lst) (car (cdr (cdr (cdr lst)))))

(define (num-calls expr)
	(cond
		((not (pair? expr)) '(1 . 0))
		((eq? (car expr) 'if) 
			(pair-add (num-calls (cadr expr))
					  (if (eval (cadr expr)) 
						  (num-calls (caddr expr)) 
						  (num-calls (cadddr expr)))))
		((eq? (car expr) 'and)
			(if (null? (cdr expr))
				'(1 . 0)
				(pair-add (num-calls (cadr expr))
						  (if (not (eval (cadr expr)))
							  '(1 . 0)
							  (num-calls (cons 'and (cdr (cdr expr))))))))
		(else (pair-add (pair-add '(0 . 1) (num-calls (car expr)))
						(reduce pair-add (map num-calls (quote (+ 2 2))))))
	))
	
(define (deep-reverse lst)
	(cond ((null? lst) nil)
		  ((list? (car lst)) (append (deep-reverse (cdr lst))
								     (list (deep-reverse (car lst)))))
		  ((null? (cdr lst)) lst)
		  (else (append (deep-reverse (cdr lst))
					    (list (car lst))))))
						
